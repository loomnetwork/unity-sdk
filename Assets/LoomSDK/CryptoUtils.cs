using Chaos.NaCl;
using System;
using System.Security.Cryptography;
using System.Text;

namespace Loom.Unity3d
{
    public class LoomCryptoSignature
    {
        /// <summary>
        /// 64-byte signature.
        /// </summary>
        public byte[] Signature { get; internal set; }
        /// <summary>
        /// 32-byte public key.
        /// </summary>
        public byte[] PublicKey { get; internal set; }
    }


    public class CryptoUtils
    {
        private static RNGCryptoServiceProvider rngCsp = new RNGCryptoServiceProvider();
        private static RIPEMD160 ripemd160 = RIPEMD160.Create();

        /// <summary>
        /// Generates a cryptographically strong sequence of random bytes.
        /// </summary>
        /// <param name="length">Number of bytes to generate.</param>
        /// <returns>Generated bytes.</returns>
        public static byte[] RandomBytes(uint length)
        {
            var random = new byte[length];
            rngCsp.GetBytes(random);
            return random;
        }

        /// <summary>
        /// Generates a 64-byte private key.
        /// </summary>
        /// <returns>A 64-byte array.</returns>
        public static byte[] GeneratePrivateKey()
        {
            var seed = new byte[32];
            rngCsp.GetBytes(seed);
            byte[] publicKey32;
            byte[] privateKey64;
            Ed25519.KeyPairFromSeed(out publicKey32, out privateKey64, seed);
            return privateKey64;
        }

        /// <summary>
        /// Generates a 32-byte public key from a 64-byte private key.
        /// </summary>
        /// <param name="privateKey">64-byte private key.</param>
        /// <returns>32-byte public key.</returns>
        public static byte[] PublicKeyFromPrivateKey(byte[] privateKey)
        {
            if (privateKey.Length != 64)
            {
                throw new ArgumentException("Expected 64-byte array", "privateKey");
            }
            var publicKey = new byte[32];
            // the last 32 bytes of the 64 byte private key is the public key
            Array.Copy(privateKey, 32, publicKey, 0, 32);
            return publicKey;
        }

        /// <summary>
        /// Generates a 64-byte signature of the given message.
        /// </summary>
        /// <param name="message">A byte array of any size.</param>
        /// <param name="privateKey">64-byte private key.</param>
        /// <returns>Signature and public key.</returns>
        public static LoomCryptoSignature Sign(byte[] message, byte[] privateKey)
        {
            byte[] signature = Ed25519.Sign(message, privateKey);
            return new LoomCryptoSignature
            {
                Signature = signature,
                PublicKey = PublicKeyFromPrivateKey(privateKey)
            };
        }

        public static string BytesToHexString(byte[] bytes)
        {
            var hex = new StringBuilder(bytes.Length * 2);
            string alphabet = "0123456789ABCDEF";

            foreach (byte b in bytes)
            {
                hex.Append(alphabet[(int)(b >> 4)]);
                hex.Append(alphabet[(int)(b & 0xF)]);
            }

            return hex.ToString();
        }

        /// <summary>
        /// Converts a hex string to an array of bytes.
        /// </summary>
        /// <param name="hexStr">Hex string to convert, it may optionally start with the "0x" prefix.</param>
        /// <returns>Array of bytes.</returns>
        public static byte[] HexStringToBytes(string hexStr)
        {
            if (hexStr.StartsWith("0x"))
            {
                return CryptoBytes.FromHexString(hexStr.Substring(2));
            }
            return CryptoBytes.FromHexString(hexStr);
        }

        /// <summary>
        /// Converts a public key to a local address (which is used as unique identifier within a DAppChain).
        /// </summary>
        /// <param name="publicKey">32-byte public key</param>
        /// <returns>Array of bytes representing a local address.</returns>
        public static byte[] LocalAddressFromPublicKey(byte[] publicKey)
        {
            return ripemd160.ComputeHash(publicKey);
        }
    }

}