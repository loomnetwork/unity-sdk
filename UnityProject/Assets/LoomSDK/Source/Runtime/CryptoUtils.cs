using Loom.Chaos.NaCl;
using System;
using System.Security.Cryptography;
using Loom.Org.BouncyCastle.Crypto.Digests;

namespace Loom.Client
{
    public static class CryptoUtils
    {
        private static readonly RNGCryptoServiceProvider rngCsp = new RNGCryptoServiceProvider();
        private static readonly RipeMD160Digest ripeMd160Digest = new RipeMD160Digest();

        /// <summary>
        /// Generates a cryptographically strong sequence of random bytes.
        /// </summary>
        /// <param name="length">Number of bytes to generate.</param>
        /// <returns>Generated bytes.</returns>
        public static byte[] RandomBytes(uint length)
        {
            var random = new byte[length];
            lock (rngCsp)
            {
                rngCsp.GetBytes(random);
            }
            return random;
        }

        /// <summary>
        /// Generates a 64-byte private key from a 32-byte seed.
        /// </summary>
        /// <param name="privateKeySeed">32-byte private key seed.</param>
        /// <returns>A 64-byte array.</returns>
        public static byte[] GeneratePrivateKey(byte[] privateKeySeed)
        {
            if (privateKeySeed == null)
                throw new ArgumentNullException(nameof(privateKeySeed));

            if (privateKeySeed.Length != 32)
                throw new ArgumentException("Expected a 32-byte array", nameof(privateKeySeed));

            byte[] publicKey32;
            byte[] privateKey64;
            Ed25519.KeyPairFromSeed(out publicKey32, out privateKey64, privateKeySeed);
            return privateKey64;
        }

        /// <summary>
        /// Generates a 64-byte private key.
        /// </summary>
        /// <returns>A 64-byte array.</returns>
        public static byte[] GeneratePrivateKey()
        {
            var seed = new byte[32];
            lock (rngCsp)
            {
                rngCsp.GetBytes(seed);
            }
            return GeneratePrivateKey(seed);
        }

        /// <summary>
        /// Generates a 32-byte public key from a 64-byte private key.
        /// </summary>
        /// <param name="privateKey">64-byte private key.</param>
        /// <returns>32-byte public key.</returns>
        public static byte[] PublicKeyFromPrivateKey(byte[] privateKey)
        {
            if (privateKey.Length != 64)
            {
                throw new ArgumentException("Expected 64-byte array", nameof(privateKey));
            }

            var publicKey = new byte[32];
            // the last 32 bytes of the 64 byte private key is the public key
            Array.Copy(privateKey, 32, publicKey, 0, 32);
            return publicKey;
        }

        /// <summary>
        /// Generates a 64-byte signature of the given message.
        /// </summary>
        /// <param name="message">A byte array of any size.</param>
        /// <param name="privateKey">64-byte private key.</param>
        /// <returns>Signature and public key.</returns>
        public static LoomCryptoSignature Sign(byte[] message, byte[] privateKey)
        {
            byte[] signature = Ed25519.Sign(message, privateKey);
            return new LoomCryptoSignature
            (
                signature,
                PublicKeyFromPrivateKey(privateKey)
            );
        }

        public static string BytesToHexString(byte[] bytes)
        {
            return CryptoBytes.ToHexStringUpper(bytes);
        }

        /// <summary>
        /// Converts a hex string to an array of bytes.
        /// </summary>
        /// <param name="hexStr">Hex string to convert, it may optionally start with the "0x" prefix.</param>
        /// <returns>Array of bytes.</returns>
        public static byte[] HexStringToBytes(string hexStr)
        {
            if (hexStr.StartsWith("0x"))
            {
                return CryptoBytes.FromHexString(hexStr.Substring(2));
            }

            return CryptoBytes.FromHexString(hexStr);
        }

        /// <summary>
        /// Converts a public key to a local address (which is used as unique identifier within a DAppChain).
        /// </summary>
        /// <param name="publicKey">32-byte public key</param>
        /// <returns>Array of bytes representing a local address.</returns>
        public static byte[] LocalAddressFromPublicKey(byte[] publicKey)
        {
            lock (ripeMd160Digest)
            {
                ripeMd160Digest.Reset();
                ripeMd160Digest.BlockUpdate(publicKey, 0, publicKey.Length);

                byte[] address = new byte[ripeMd160Digest.GetDigestSize()];
                ripeMd160Digest.DoFinal(address, 0);
                return address;
            }
        }
    }
}
