using Loom.Chaos.NaCl;
using System;
using System.Security.Cryptography;
using System.Text;

namespace Loom.Client
{
    public static class CryptoUtils
    {
        private static readonly RNGCryptoServiceProvider rngCsp = new RNGCryptoServiceProvider();
        private static readonly RIPEMD160 ripemd160 = RIPEMD160.Create();

        /// <summary>
        /// Generates a cryptographically strong sequence of random bytes.
        /// </summary>
        /// <param name="length">Number of bytes to generate.</param>
        /// <returns>Generated bytes.</returns>
        public static byte[] RandomBytes(uint length)
        {
            var random = new byte[length];
            rngCsp.GetBytes(random);
            return random;
        }

        /// <summary>
        /// Generates a 64-byte private key from a 32-byte seed.
        /// </summary>
        /// <param name="privateKeySeed">32-byte private key seed.</param>
        /// <returns>A 64-byte array.</returns>
        public static byte[] GeneratePrivateKey(byte[] privateKeySeed)
        {
            if (privateKeySeed == null)
                throw new ArgumentNullException("privateKeySeed");

            if (privateKeySeed.Length != 32)
                throw new ArgumentException("Expected a 32-byte array", "privateKeySeed");

            byte[] publicKey32;
            byte[] privateKey64;
            Ed25519.KeyPairFromSeed(out publicKey32, out privateKey64, privateKeySeed);
            return privateKey64;
        }

        /// <summary>
        /// Generates a 64-byte private key.
        /// </summary>
        /// <returns>A 64-byte array.</returns>
        public static byte[] GeneratePrivateKey()
        {
            var seed = new byte[32];
            rngCsp.GetBytes(seed);
            return GeneratePrivateKey(seed);
        }

        /// <summary>
        /// Generates a 32-byte public key from a 64-byte private key.
        /// </summary>
        /// <param name="privateKey">64-byte private key.</param>
        /// <returns>32-byte public key.</returns>
        public static byte[] PublicKeyFromPrivateKey(byte[] privateKey)
        {
            if (privateKey.Length != 64)
            {
                throw new ArgumentException("Expected 64-byte array", "privateKey");
            }

            var publicKey = new byte[32];
            // the last 32 bytes of the 64 byte private key is the public key
            Array.Copy(privateKey, 32, publicKey, 0, 32);
            return publicKey;
        }

        /// <summary>
        /// Generates a 64-byte signature of the given message.
        /// </summary>
        /// <param name="message">A byte array of any size.</param>
        /// <param name="privateKey">64-byte private key.</param>
        /// <returns>Signature and public key.</returns>
        public static LoomCryptoSignature Sign(byte[] message, byte[] privateKey)
        {
            byte[] signature = Ed25519.Sign(message, privateKey);
            return new LoomCryptoSignature
            (
                signature,
                PublicKeyFromPrivateKey(privateKey)
            );
        }

        public static string BytesToHexString(byte[] bytes)
        {
            var hex = new StringBuilder(bytes.Length * 2);
            string alphabet = "0123456789ABCDEF";

            foreach (byte b in bytes)
            {
                hex.Append(alphabet[(int) (b >> 4)]);
                hex.Append(alphabet[(int) (b & 0xF)]);
            }

            return hex.ToString();
        }

        /// <summary>
        /// Converts a hex string to an array of bytes.
        /// </summary>
        /// <param name="hexStr">Hex string to convert, it may optionally start with the "0x" prefix.</param>
        /// <returns>Array of bytes.</returns>
        public static byte[] HexStringToBytes(string hexStr)
        {
            if (hexStr.StartsWith("0x"))
            {
                return CryptoBytes.FromHexString(hexStr.Substring(2));
            }

            return CryptoBytes.FromHexString(hexStr);
        }

        /// <summary>
        /// Converts a public key to a local address (which is used as unique identifier within a DAppChain).
        /// </summary>
        /// <param name="publicKey">32-byte public key</param>
        /// <returns>Array of bytes representing a local address.</returns>
        public static byte[] LocalAddressFromPublicKey(byte[] publicKey)
        {
            return ripemd160.ComputeHash(publicKey);
        }
    }
}
